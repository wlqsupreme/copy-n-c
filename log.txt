议题说明 
议题一 开发一个根据一篇小说生成相应漫画的应用。 
请回答: 
1.你计划将这个产品面向什么类型的用户?这些类型的用户他们面临什么样的痛点，你设想的用户故事是什么样呢? 
2.你认为这个产品实现上的挑战是什么，你计划如何应对这些挑战? 
3.你计划采纳哪家公司的哪个模型的AIGC功能?你对比了哪些，你为什么选择用该API? 
4.你对这个产品有哪些未来规划中的功能?你为何觉得这些能力是重要的? 
请开发以上应用。要求不能调用第三方的agent能力，只需允许调用LLM、各类AIGC模型和语音TTS能力。
同时针对以上1-4点，请把你的思考整理成文档，作为作品的说明一并提交。


@log.txt 根据整体项目情况与log.txt，
新建一个readme文档，新文档还是把议题说明写在最前面（1-9行），
然后总结一下现在情况，
从依赖配置到gitignore到虚拟环境的创建、数据库的连接、还有现在的后端与前端都干了哪些东西



python版本

你不需要“降级”你电脑的 Python。你只需要\*\*“并存”**，然后**告诉虚拟环境（venv）它该用哪个\*\*。

你现在电脑上装了 Python 3.13。你需要做的，只是**再安装一个 Python 3.11**，然后用 3.11 来**创建**这个项目的虚拟环境。你其他的项目**完全不受影响**。

#### 步骤一：安装 Python 3.11 (与 3.13 并存)

1.  去 Python 官方网站 (python.org)。
2.  下载 **Python 3.11** 的 Windows 64位安装包 (Windows installer)。
3.  运行安装包。**在安装界面上，请注意：**
      * **不要** 勾选 "Make this the default Python" 或 "Add to PATH" （如果你担心影响其他项目，就都别勾选）。
      * **必须** 确保 "Install for all users" 和 "Install `py.exe` launcher" 是勾选的（通常默认就是）。
4.  完成安装。现在你的电脑上同时拥有 Python 3.13 和 3.11。`py.exe` 启动器知道它们分别在哪里。

#### 步骤二：使用 3.11 创建新的虚拟环境

这是最关键的一步。

1.  打开你的命令行，进入 `backend` 目录。

2.  **删除旧的、坏的 venv：**

    ```bash
    rmdir /s /q venv 
    ```

    *(如果提示无权限，直接用文件管理器右键删除 `venv` 文件夹)*

3.  **【魔法在这里】** 使用 `py.exe` 启动器，**指定用 3.11 版本**来创建 venv：

    ```bash
    py -3.11 -m venv venv
    ```

      * `py -3.11` 的意思就是“嘿，Windows，请使用我安装的 3.11 版本的 Python...”。
      * `... -m venv venv` 的意思就是“...来创建一个名为 venv 的虚拟环境”。

4.  **激活新环境并安装依赖：**

    ```bash
    # 激活这个新创建的、基于 3.11 的 venv
    venv\Scripts\activate

    # 你的命令行提示符现在会显示 (venv)
    # 检查一下版本 (可选)
    (venv) ...> python -V 
    # (此时应该会显示 Python 3.11.x)

    # 再次运行安装
    (venv) ...> pip install -r requirements.txt 
    ```

**大功告成。**

这一次，`pip` 会在 Python 3.11 的环境里运行，它会找到 `asyncpg` 官方为 Python 3.11 提供的、**已经编译好的** `.whl` 文件，直接下载安装，**根本不会在你本地进行编译**，也就不会再报错了。

你的项目现在运行在隔离的 3.11 venv 中，而你其他所有的项目和你全局的 Python 3.13 毫发无损。





py -3.11 -m venv venv
venv\Scripts\activate
(venv) ...> python -V
pip install -r requirements.txt
# 启动服务
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

python test_db.py







-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.characters (
  character_id uuid NOT NULL DEFAULT gen_random_uuid(),
  project_id uuid NOT NULL,
  name character varying NOT NULL,
  description text,
  reference_image_urls json,
  lora_model_path character varying,
  trigger_word character varying,
  CONSTRAINT characters_pkey PRIMARY KEY (character_id),
  CONSTRAINT characters_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(project_id)
);
CREATE TABLE public.projects (
  project_id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  title character varying NOT NULL,
  description text,
  visibility USER-DEFINED DEFAULT 'private'::project_visibility,
  default_style_prompt text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
  CONSTRAINT projects_pkey PRIMARY KEY (project_id),
  CONSTRAINT projects_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id)
);
CREATE TABLE public.source_texts (
  text_id uuid NOT NULL DEFAULT gen_random_uuid(),
  project_id uuid NOT NULL,
  title character varying DEFAULT 'Untitled Chapter'::character varying,
  raw_content text NOT NULL,
  order_index integer DEFAULT 0,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
  CONSTRAINT source_texts_pkey PRIMARY KEY (text_id),
  CONSTRAINT source_texts_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(project_id)
);
CREATE TABLE public.users (
  user_id uuid NOT NULL DEFAULT gen_random_uuid(),
  username character varying NOT NULL UNIQUE,
  email character varying NOT NULL UNIQUE,
  hashed_password character varying NOT NULL,
  credit_balance integer DEFAULT 0,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
  CONSTRAINT users_pkey PRIMARY KEY (user_id)
);








supabase数据库设计与创建
-- ----------------------------
-- 0. 创建一个函数，用于自动更新 'updated_at' 字段的时间戳
-- (PostgreSQL 中 'ON UPDATE' 功能的实现方式)
-- ----------------------------
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- ----------------------------
-- 1. 为 'projects' 表创建 ENUM 类型
-- (PostgreSQL 推荐的方式)
-- ----------------------------
CREATE TYPE project_visibility AS ENUM ('private', 'public');


-- ----------------------------
-- 表 1: users (用户信息表)
-- ----------------------------
CREATE TABLE "users" (
    "user_id" UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- 改为 UUID 类型并自动生成
    "username" VARCHAR(100) UNIQUE NOT NULL,
    "email" VARCHAR(255) UNIQUE NOT NULL,
    "hashed_password" VARCHAR(255) NOT NULL,
    "credit_balance" INT DEFAULT 0,
    "created_at" TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()), -- Supabase 推荐使用带时区的时间
    "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 表 1 的注解
COMMENT ON TABLE "users" IS '用户信息表';
COMMENT ON COLUMN "users"."user_id" IS '唯一用户ID (UUID)';
COMMENT ON COLUMN "users"."username" IS '用户名 (用于登录，必须唯一)';
COMMENT ON COLUMN "users"."email" IS '电子邮箱 (用于登录或找回密码，必须唯一)';
COMMENT ON COLUMN "users"."hashed_password" IS '加密后的密码 (例如使用bcrypt或Argon2)';
COMMENT ON COLUMN "users"."credit_balance" IS '可使用额度 (例如: 剩余可生成图片张数或Token数)';
COMMENT ON COLUMN "users"."created_at" IS '账户创建时间';
COMMENT ON COLUMN "users"."updated_at" IS '账户信息最后更新时间';

-- 表 1 的 'updated_at' 触发器
CREATE TRIGGER set_users_updated_at
BEFORE UPDATE ON "users"
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();


-- ----------------------------
-- 表 2: projects (漫画项目表)
-- ----------------------------
DROP TABLE IF EXISTS "projects";
CREATE TABLE "projects" (
    "project_id" UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- 改为 UUID
    "user_id" UUID NOT NULL, -- 改为 UUID
    "title" VARCHAR(255) NOT NULL,
    "description" TEXT,
    "visibility" project_visibility DEFAULT 'private', -- 使用上面创建的 ENUM 类型
    "default_style_prompt" TEXT,
    "created_at" TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    FOREIGN KEY ("user_id") REFERENCES "users"("user_id") ON DELETE CASCADE
);

-- 表 2 的注解
COMMENT ON TABLE "projects" IS '漫画项目表';
COMMENT ON COLUMN "projects"."project_id" IS '唯一项目ID (UUID)';
COMMENT ON COLUMN "projects"."user_id" IS '外键，关联到 users(user_id)，表示该项目的所有者';
COMMENT ON COLUMN "projects"."title" IS '项目标题 (例如 "我的XX小说改编")';
COMMENT ON COLUMN "projects"."description" IS '项目描述';
COMMENT ON COLUMN "projects"."visibility" IS '可见性：private(仅自己), public(他人可见)';
COMMENT ON COLUMN "projects"."default_style_prompt" IS '项目的默认风格提示词 (例如 "shonen manga, high contrast")';
COMMENT ON COLUMN "projects"."created_at" IS '项目创建时间';
COMMENT ON COLUMN "projects"."updated_at" IS '项目最后更新时间';

-- 表 2 的 'updated_at' 触发器
CREATE TRIGGER set_projects_updated_at
BEFORE UPDATE ON "projects"
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();


-- ----------------------------
-- 表 3: source_texts (小说原文表)
-- ----------------------------
DROP TABLE IF EXISTS "source_texts";
CREATE TABLE "source_texts" (
    "text_id" UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- 改为 UUID
    "project_id" UUID NOT NULL, -- 改为 UUID
    "title" VARCHAR(255) DEFAULT 'Untitled Chapter',
    "raw_content" TEXT NOT NULL, -- LONGTEXT 变为 TEXT
    "order_index" INT DEFAULT 0,
    "created_at" TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    FOREIGN KEY ("project_id") REFERENCES "projects"("project_id") ON DELETE CASCADE
);

-- 表 3 的注解
COMMENT ON TABLE "source_texts" IS '小说原文表';
COMMENT ON COLUMN "source_texts"."text_id" IS '唯一文本ID (UUID)';
COMMENT ON COLUMN "source_texts"."project_id" IS '外键，关联到 projects(project_id)';
COMMENT ON COLUMN "source_texts"."title" IS '标题 (例如 "第一章" 或 "番外篇")';
COMMENT ON COLUMN "source_texts"."raw_content" IS '存储用户上传的原始小说文本 (PostgreSQL的TEXT类型已足够)';
COMMENT ON COLUMN "source_texts"."order_index" IS '用于章节或文本片段的排序';
COMMENT ON COLUMN "source_texts"."created_at" IS '上传时间';


-- ----------------------------
-- 表 4: characters (项目角色表)
-- ----------------------------
DROP TABLE IF EXISTS "characters";
CREATE TABLE "characters" (
    "character_id" UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- 改为 UUID
    "project_id" UUID NOT NULL, -- 改为 UUID
    "name" VARCHAR(255) NOT NULL,
    "description" TEXT,
    "reference_image_urls" JSON, -- PostgreSQL 原生支持 JSON, 很好
    "lora_model_path" VARCHAR(1024),
    "trigger_word" VARCHAR(100),
    FOREIGN KEY ("project_id") REFERENCES "projects"("project_id") ON DELETE CASCADE
);

-- 表 4 的注解
COMMENT ON TABLE "characters" IS '项目角色表';
COMMENT ON COLUMN "characters"."character_id" IS '唯一角色ID (UUID)';
COMMENT ON COLUMN "characters"."project_id" IS '外键，关联到 projects(project_id)';
COMMENT ON COLUMN "characters"."name" IS '角色名称 (例如 "张三")';
COMMENT ON COLUMN "characters"."description" IS '角色外貌、性格描述 (给LLM用)';
COMMENT ON COLUMN "characters"."reference_image_urls" IS '角色参考图URL列表 (JSON数组格式, 存储S3/OSS的URL)';
COMMENT ON COLUMN "characters"."lora_model_path" IS '指向 S3/OSS 上的LoRA模型或Embedding文件路径';
COMMENT ON COLUMN "characters"."trigger_word" IS '触发该LoRA的关键词 (例如 "ohwx_zhangsan")';







有登录注册，未登录状态下无法使用功能，只能看别人的作品
    数据库：用户信息表（账号密码可使用额度等）

文本解析层（LLM）：把原文拆成场景、人物、动作、情绪、关键道具与对话；输出结构化脚本（JSON）。
    数据库：用户上传的小说文字或者文件应进行存储，具体如何存储这些大量的文字还不确定

分镜规划层（LLM 或规则逻辑）：根据场景节奏决定每页面板数、镜头类型、构图要点（近景/远景/鸟瞰）并生成每个 panel 的描述。
    数据库：文本解析之后的详细分镜信息应进行存储，存储这些文字也不确定怎么存





文本到分镜（story-to-panel）需要理解剧情节点、镜头构图、节奏。

图像一致性（人物在不同画面保持相貌、服装）。

对话气泡与文字排版的可读性。

生成漫画风格的高质量图像（漫画线条、上色、阴影）。

长文本的上下文保持与分场景切分。

性能与成本（大模型调用、GPU）。

应对策略

分层管线（pipeline）设计：

文本解析层（LLM）：把原文拆成场景、人物、动作、情绪、关键道具与对话；输出结构化脚本（JSON）。

分镜规划层（LLM 或规则逻辑）：根据场景节奏决定每页面板数、镜头类型、构图要点（近景/远景/鸟瞰）并生成每个 panel 的描述。

图像生成层（AIGC）：对每个 panel 的描述调用文本到图像模型（可配合 ControlNet/pose/segmentation 引导）生成草稿，使用人物一致性机制（参考：人物 embedding、参考图像或 LoRA/专属 embedding）以维持一致性。

后处理层：气泡排版（文本渲染）、图像合成、色彩调整、去噪与风格一致化（可用图像到图像微调/循环修正）。

保持人物一致性的技巧：

允许用户上传 2–4 张角色参考图（或角色描述卡），并使用专属 embedding / LoRA / DreamBooth（或自托管等价）以保持风格一致。

在生成中使用先生成草图，然后对草图做风格迁移的两阶段流程。

长文本处理：分段摘要 + 场景划分，先用 LLM 做“剧情压缩”，再逐段生成分镜。

成本控制：

把实时交互（浏览器预览、小图）用小模型或低分辨率生成；把高质量渲染放到异步队列，按需付费或让用户购买渲染额度。

缓存与去重（相同 prompt 与相同种子不重复生成）。

可控性与编辑性：提供 UI 让用户修改分镜（移动/合并/分割 panel）、替换单幅图像并重新批量渲染。





随着功能（如文生图）的增加，把所有逻辑都堆在 `main.py` 中很快会变成一场“灾难”，极难维护和协作。

您已经成功地将数据库逻辑分离到了 `app/db/` 目录中，这是一个非常棒的开始！

针对您“保持结构简单、便于协作”的需求，我推荐一个既专业又简洁的方案：**将`main.py`拆分为“API路由层”和“AI服务层”**。

这完全符合您的协作模式：您可以专注于`storyboard`（分镜）相关的服务和API，而您的协作者可以独立开发`image_gen`（图像生成）的服务和API，互不干扰。

-----

### 建议的目录结构（改动最小）

这是在您**现有**结构上扩展的最简方案：

```
backend/
├── app/
│   ├── db/                 # (您已完成) 数据库操作，不动
│   │   ├── client.py
│   │   ├── crud.py
│   │   └── models.py
│   │
│   ├── api/                # (新建) API路由层 (Web接口)
│   │   ├── __init__.py
│   │   ├── storyboard.py   # (新建) 负责你所有的分镜API
│   │   ├── project.py      # (新建) 负责项目管理的API
│   │   └── image_gen.py    # (协作者的文件) 负责图像生成的API
│   │
│   ├── services/           # (新建) AI服务层 (核心逻辑)
│   │   ├── __init__.py
│   │   ├── ai_parser.py    # (新建) 你的小说解析、分镜规划逻辑
│   │   └── ai_image.py     # (协作者的文件) 他的文生图逻辑
│   │
│   └── main.py             # (修改) 变得非常"瘦"，只负责启动和组装
│
├── config.py               # 不动
├── test_db.py              # 不动
└── requirements.txt        # 不动
```

-----

### 如何拆分：三步走

#### 第1步：创建 `services` (AI服务层)

这个文件只放纯粹的AI处理逻辑，它不应该知道“API”或“HTTP”是什么。

**新建 `backend/app/services/ai_parser.py` 文件：**
(将 `main.py` 中的AI相关函数**剪切**并**粘贴**到这里)

```python
# backend/app/services/ai_parser.py
import httpx
import json
import re
from config import config

QINIU_API_BASE = "https://openai.qiniu.com/v1"  # 七牛 openai 兼容入口

async def call_qiniu_api(messages: list) -> dict:
    """调用七牛云API的通用函数"""
    payload = {
        "model": config.model,
        "messages": messages,
        "max_tokens": config.max_tokens,
        "temperature": config.temperature
    }
    headers = {
        "Authorization": f"Bearer {config.api_key}",
        "Content-Type": "application/json"
    }
    url = f"{QINIU_API_BASE}/chat/completions"
    
    print(f"🚀(AI服务) 开始调用七牛云API...")
    
    async with httpx.AsyncClient(timeout=config.timeout) as client:
        try:
            r = await client.post(url, headers=headers, json=payload)
            r.raise_for_status() # 确保HTTP错误会抛出异常
            
            print(f"📥(AI服务) 收到响应: {r.status_code}")
            data = r.json()
            
            # (省略了您已有的解析 content 和 JSON 的逻辑...)
            content = data.get("choices", [{}])[0].get("message", {}).get("content", "{}")
            
            parsed = None
            try:
                parsed = json.loads(content)
            except Exception:
                m = re.search(r"\{[\s\S]*\}", content)
                if m:
                    try:
                        parsed = json.loads(m.group(0))
                    except Exception:
                        parsed = None
            return parsed

        except httpx.RequestError as e:
            print(f"❌(AI服务) 网络请求失败: {e}")
            return None
        except Exception as e:
            print(f"❌(AI服务) API调用失败: {e}")
            return None


async def generate_storyboard_for_segment(segment_text: str, title: str, segment_index: int) -> list:
    """为单个文本段生成分镜"""
    print(f"🎬(AI服务) 开始生成分镜 (段落 {segment_index})...")
    
    messages = [
        {"role": "system", "content": "你是一个专业的分镜脚本生成器... (省略system prompt) ..."},
        {"role": "user", "content": f"标题: {title or ''}\n段落 {segment_index}:\n{segment_text}\n\n请生成分镜JSON，每页3-6个panel。"}
    ]
    
    result = await call_qiniu_api(messages)
    if result and "pages" in result:
        print(f"✅(AI服务) 分镜生成成功，生成 {len(result['pages'])} 页")
        return result["pages"]
    else:
        print(f"❌(AI服务) 分镜生成失败")
        return []

def simple_text_segment(text: str) -> list:
    """简单的文本分段规则"""
    # (省略了您已有的简单分段逻辑...)
    segments = []
    paragraphs = text.split('\n\n')
    current_segment = ""
    segment_index = 1
    
    for para in paragraphs:
        if len(current_segment + para) > 1000 and current_segment:
            segments.append({"segment_index": segment_index, "content": current_segment.strip(), "summary": "..."})
            current_segment = para
            segment_index += 1
        else:
            current_segment += "\n\n" + para if current_segment else para
    
    if current_segment:
        segments.append({"segment_index": segment_index, "content": current_segment.strip(), "summary": "..."})
    
    return segments


async def segment_text(text: str) -> list:
    """将长文本分段"""
    print(f"📝(AI服务) 开始AI智能分段...")
    messages = [
        {"role": "system", "content": "你是一个文本分段专家... (省略system prompt) ..."},
        {"role": "user", "content": f"请将以下文本分段：\n\n{text}"}
    ]
    
    result = await call_qiniu_api(messages)
    if result and "segments" in result:
        print(f"✅(AI服务) AI分段成功，生成 {len(result['segments'])} 段")
        return result["segments"]
    else:
        print(f"⚠️(AI服务) AI分段失败，使用规则分段...")
        segments = simple_text_segment(text)
        print(f"✅(AI服务) 规则分段完成，生成 {len(segments)} 段")
        return segments
```

#### 第2步：创建 `api` (API路由层)

这个文件只负责处理HTTP请求和响应。它调用 `services` 层来完成工作，调用 `db` 层来存取数据。

**新建 `backend/app/api/storyboard.py` 文件：**
(将 `main.py` 中与分镜相关的API**剪切**并**粘贴**到这里)

```python
# backend/app/api/storyboard.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Any, Dict

# 导入db和服务
from app.db import db_client, save_storyboard, Storyboard
from app.services import ai_parser # 导入我们刚创建的AI服务

router = APIRouter()

# 把 Pydantic 模型也移过来
class ParseRequest(BaseModel):
    title: str | None = None
    text: str
    auto_segment: bool = True
    user_id: str | None = None
    project_id: str | None = None

class SaveStoryboardRequest(BaseModel):
    project_id: str
    storyboard: Dict[str, Any]

# --- 场景1：创建分镜 ---
@router.post("/api/v1/parse", tags=["Storyboard"])
async def parse_text(req: ParseRequest):
    """
    接收小说文本，调用AI生成分镜，并存入数据库。
    (这是您数据流中的“创建”场景)
    """
    print(f"📖(API) 收到解析请求: {req.project_id}")
    
    # 1. 调用AI服务层处理逻辑
    if req.auto_segment and len(req.text) > 1000:
        segments = await ai_parser.segment_text(req.text)
        all_pages = []
        for i, segment in enumerate(segments):
            pages = await ai_parser.generate_storyboard_for_segment(segment, req.title, i + 1)
            all_pages.extend(pages)
    else:
        all_pages = await ai_parser.generate_storyboard_for_segment(req.text, req.title, 1)

    storyboard_obj = Storyboard.from_dict({"pages": all_pages})
    
    # 2. 调用DB层存入数据库
    if req.project_id and db_client.is_connected:
        try:
            success = await save_storyboard(req.project_id, storyboard_obj)
            if success:
                print(f"✅(API) 分镜已保存到项目 {req.project_id}")
            else:
                print(f"⚠️(API) 分镜保存失败")
        except Exception as e:
            print(f"❌(API) 保存分镜到数据库失败: {e}")
            
    # 3. 直接将内存中的结果返回给前端 (最高效)
    return {"ok": True, "storyboard": storyboard_obj.to_dict()}

# --- 场景3：保存分镜 ---
@router.post("/api/v1/save-storyboard", tags=["Storyboard"])
async def save_storyboard_endpoint(req: SaveStoryboardRequest):
    """
    保存分镜数据到数据库
    (这是您数据流中的“编辑保存”场景)
    """
    print(f"💾(API) 收到保存请求: {req.project_id}")
    if not db_client.is_connected:
        raise HTTPException(status_code=500, detail="数据库未连接")
    
    try:
        storyboard = Storyboard.from_dict(req.storyboard)
        success = await save_storyboard(req.project_id, storyboard)
        
        if success:
            return {"ok": True, "message": "分镜保存成功"}
        else:
            raise HTTPException(status_code=500, detail="分镜保存失败")
            
    except Exception as e:
        print(f"❌(API) 保存分镜失败: {e}")
        raise HTTPException(status_code=500, detail=f"保存分镜失败: {str(e)}")

```

**新建 `backend/app/api/project.py` 文件：**
(将 `main.py` 中与项目相关的API**剪切**并**粘贴**到这里)

```python
# backend/app/api/project.py
from fastapi import APIRouter, HTTPException
from typing import List

# 导入db
from app.db import (
    db_client, create_project, get_projects_by_user,
    get_project_by_id, load_storyboard, get_public_projects,
    ProjectVisibility
)

router = APIRouter()

@router.post("/api/v1/create-project", tags=["Project"])
async def create_project_endpoint(
    user_id: str,
    title: str,
    description: str | None = None,
    visibility: str = "private"
):
    # (省略了您已有的 create_project_endpoint 逻辑...)
    if not db_client.is_connected:
        raise HTTPException(status_code=500, detail="数据库未连接")
    try:
        vis_enum = ProjectVisibility(visibility)
        project = await create_project(
            user_id=user_id, title=title, description=description, visibility=vis_enum
        )
        if project:
            return {"ok": True, "project": project.to_dict()}
        else:
            raise HTTPException(status_code=500, detail="项目创建失败")
    except Exception as e:
        print(f"❌(API) 创建项目失败: {e}")
        raise HTTPException(status_code=500, detail=f"创建项目失败: {str(e)}")


@router.get("/api/v1/projects/{user_id}", tags=["Project"])
async def get_user_projects(user_id: str):
    # (省略了您已有的 get_user_projects 逻辑...)
    if not db_client.is_connected:
        raise HTTPException(status_code=500, detail="数据库未连接")
    projects = await get_projects_by_user(user_id)
    return {"ok": True, "projects": [project.to_dict() for project in projects]}

# --- 场景2：加载分镜 ---
@router.get("/api/v1/project/{project_id}", tags=["Project"])
async def get_project(project_id: str):
    """
    获取项目详情，包含分镜数据
    (这是您数据流中的“加载已有”场景)
    """
    print(f"📂(API) 收到加载请求: {project_id}")
    if not db_client.is_connected:
        raise HTTPException(status_code=500, detail="数据库未连接")
    
    try:
        project = await get_project_by_id(project_id)
        if not project:
            raise HTTPException(status_code=404, detail="项目不存在")
        
        # 核心：加载分镜数据
        storyboard = await load_storyboard(project_id)
        
        result = project.to_dict()
        if storyboard:
            result["storyboard"] = storyboard.to_dict() # 把分镜数据塞进去
        
        return {"ok": True, "project": result}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"❌(API) 获取项目失败: {e}")
        raise HTTPException(status_code=500, detail=f"获取项目失败: {str(e)}")


@router.get("/api/v1/public-projects", tags=["Project"])
async def get_public_projects_endpoint(limit: int = 20, offset: int = 0):
    # (省略了您已有的 get_public_projects 逻辑...)
    if not db_client.is_connected:
        raise HTTPException(status_code=500, detail="数据库未连接")
    projects = await get_public_projects(limit=limit, offset=offset)
    return {"ok": True, "projects": [project.to_dict() for project in projects]}

```

#### 第3步：修改 `main.py` (组装)

现在您的 `main.py` 会变得极其干净：

```python
# backend/app/main.py
import sys
import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

# 添加 backend 目录到 Python 路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from config import config
from app.db import init_database, close_database, db_client
from app.api import storyboard, project # 导入新的API路由

# (如果协作者添加了 image_gen, 在这里导入)
# from app.api import image_gen 

# 检查配置是否有效
if not config.is_valid():
    print(config.get_error_message())
    sys.exit(1)

app = FastAPI()

# 添加 CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 挂载您的API路由
app.include_router(storyboard.router)
app.include_router(project.router)
# (如果协作者添加了 image_gen, 在这里挂载)
# app.include_router(image_gen.router)


# 数据库启动和关闭事件 (保持不变)
@app.on_event("startup")
async def startup_event():
    """应用启动时初始化数据库"""
    print("🚀 应用启动中...")
    if config.is_database_configured():
        success = await init_database()
        if success:
            is_connected = await db_client.test_connection()
            if is_connected:
                print("✅ Supabase数据库连接测试成功")
            else:
                print("❌ Supabase数据库连接测试失败")
    else:
        print("⚠️ 数据库未配置，跳过数据库初始化")

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭时清理资源"""
    print("🛑 应用关闭中...")
    await close_database()


@app.get("/health")
async def health():
    return {"status": "ok"}

# ---------------------------------------------------
# (main.py 中所有的业务逻辑 / API endpoint 都被移走了)
# ---------------------------------------------------
```